
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_NANO_SoC_GHRD(

    //////////// CLOCK //////////
    input               FPGA_CLK1_50,
    input               FPGA_CLK2_50,
    input               FPGA_CLK3_50,

    //////////// HPS //////////
    output   [14: 0]    HPS_DDR3_ADDR,
    output   [ 2: 0]    HPS_DDR3_BA,
    output              HPS_DDR3_CAS_N,
    output              HPS_DDR3_CK_N,
    output              HPS_DDR3_CK_P,
    output              HPS_DDR3_CKE,
    output              HPS_DDR3_CS_N,
    output   [ 3: 0]    HPS_DDR3_DM,
    inout    [31: 0]    HPS_DDR3_DQ,
    inout    [ 3: 0]    HPS_DDR3_DQS_N,
    inout    [ 3: 0]    HPS_DDR3_DQS_P,
    output              HPS_DDR3_ODT,
    output              HPS_DDR3_RAS_N,
    output              HPS_DDR3_RESET_N,
    input               HPS_DDR3_RZQ,
    output              HPS_DDR3_WE_N,

	// FPGA ADC LTC2308 (SPI)
	output ADC_CONVST,
	output ADC_SCK,
	output ADC_SDI,
	input  ADC_SDO,
    
    //////////// LED //////////
    output   [ 7: 0]    LED
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire hps_fpga_reset_n;
//wire     [6: 0]     fpga_led_internal;
wire                fpga_clk_50;
// connection of internal logics
//assign LED[7: 1] = fpga_led_internal;
assign fpga_clk_50 = FPGA_CLK1_50;

	// Wires for the PLL clock and reset
	wire pll0_clock0;
//	wire pll0_clock1;
	wire pll0_locked;
	wire my_reset = ~hps_fpga_reset_n | ~pll0_locked;  // Stay in reset if pll is not locked

	// PLL module instance
	pll (
	.refclk(FPGA_CLK1_50),   
	.outclk_0(pll0_clock0),	 // 40 MHz
	.locked(pll0_locked)
	);
	
	// ==========================
	// ADC LT2308 module instance
	// ==========================
	
	wire adc_ready;
	wire [11:0] adc_data;
	adc_ltc2308 adc0(
		.clock(pll0_clock0),
		.reset(my_reset),
		.start(1'b1),
		.channel(0),
		.ready(adc_ready),
		.data(adc_data),
		.CONVST(ADC_CONVST),
		.SCK(ADC_SCK),
		.SDI(ADC_SDI),
		.SDO(ADC_SDO)
	);

	// ========================================
	// Control loop to send ADC samples to UART
	// ========================================
	
//	// UART messages, etc..
//	localparam UART_MSG1_LEN = 6;
//	localparam [8*UART_MSG1_LEN-1:0] uart_msg1 = "ch0=0x";
//	localparam UART_ADC_DATA_LEN = 2;
	reg [15:0] uart_adc_data;
//	reg [2:0] uart_msg_counter;  // Max value = 2^(2+1) = 8. Value must be equal or greater than longest message
//	
	reg [3:0] state;
	reg [24:0] counter;
//	reg [15:0] ledstate;

	assign LED[7:1] = uart_adc_data[11:5];
	
	always @ (posedge pll0_clock0 or posedge my_reset) begin
		// STATE: Reset?
		if(my_reset) begin
//			uart_enable <= 0;
			state <= 0;
			counter <= 0;
		end else begin

			case(state)
				
				// Delay
				0: begin
					if(counter == {25{1'b1}}) begin	// SVH: Replicate "1" 25 times = 33554431 40 MHz cycles ~= 0.84 s
						counter <= 0;
//						uart_msg_counter <= UART_MSG1_LEN - 1;
						state <= state + 1;
					end else begin
						counter <= counter + 1;
					end
				end
				
//				// Transmit uart_msg1 to UART
//				1: begin
//					case(uart_status)
//						0: begin
//							uart_data <= uart_msg1[8*uart_msg_counter +: 8];
//							uart_input_type <= 0;
//							uart_data_len <= 1;
//							uart_hex <= 0;
//							uart_new_line <= 0;
//							uart_enable <= 1;
//						end
//						2: begin
//							uart_enable <= 0;
//							if(uart_msg_counter > 0) begin
//								uart_msg_counter <= uart_msg_counter - 1;
//							end else begin
//								state <= state + 1;
//							end
//						end
//					endcase
//				end
//				
				// Wait for ADC data sample ready
//				2: begin
				1: begin
					if(adc_ready) begin
						uart_adc_data <= adc_data;
//						uart_msg_counter <= UART_ADC_DATA_LEN - 1;
						state <= state + 1;
					end
				end
				
//				// Transmit ADC data sample as hex value to UART 
//				3: begin
//					case(uart_status)
//						0: begin
//							uart_data <= uart_adc_data[8*uart_msg_counter +: 8];
//							uart_input_type <= 0;
//							uart_data_len <= 1;
//							uart_hex <= 1;
//							uart_new_line <= 0;
//							uart_enable <= 1;
//						end
//						2: begin
//							uart_enable <= 0;
//							if(uart_msg_counter > 0) begin
//								uart_msg_counter <= uart_msg_counter - 1;
//							end else begin
//								state <= state + 1;
//							end
//						end
//					endcase
//				end

				// Set LEDS based on ADC
				2: begin
//					ledstate <= uart_adc_data;
					state <= 0;
				end
			endcase
		end
	end


//=======================================================
//  Structural coding
//=======================================================
soc_system u0(
					.adcvalue_export(uart_adc_data),
               //Clock&Reset
               .clk_clk(FPGA_CLK1_50),                                      //                            clk.clk
               .reset_reset_n(hps_fpga_reset_n),                            //                          reset.reset_n
               //HPS ddr3
               .memory_mem_a(HPS_DDR3_ADDR),                                //                         memory.mem_a
               .memory_mem_ba(HPS_DDR3_BA),                                 //                               .mem_ba
               .memory_mem_ck(HPS_DDR3_CK_P),                               //                               .mem_ck
               .memory_mem_ck_n(HPS_DDR3_CK_N),                             //                               .mem_ck_n
               .memory_mem_cke(HPS_DDR3_CKE),                               //                               .mem_cke
               .memory_mem_cs_n(HPS_DDR3_CS_N),                             //                               .mem_cs_n
               .memory_mem_ras_n(HPS_DDR3_RAS_N),                           //                               .mem_ras_n
               .memory_mem_cas_n(HPS_DDR3_CAS_N),                           //                               .mem_cas_n
               .memory_mem_we_n(HPS_DDR3_WE_N),                             //                               .mem_we_n
               .memory_mem_reset_n(HPS_DDR3_RESET_N),                       //                               .mem_reset_n
               .memory_mem_dq(HPS_DDR3_DQ),                                 //                               .mem_dq
               .memory_mem_dqs(HPS_DDR3_DQS_P),                             //                               .mem_dqs
               .memory_mem_dqs_n(HPS_DDR3_DQS_N),                           //                               .mem_dqs_n
               .memory_mem_odt(HPS_DDR3_ODT),                               //                               .mem_odt
               .memory_mem_dm(HPS_DDR3_DM),                                 //                               .mem_dm
               .memory_oct_rzqin(HPS_DDR3_RZQ),                             //                               .oct_rzqin

               .hps_0_h2f_reset_reset_n(hps_fpga_reset_n),                  //                hps_0_h2f_reset.reset_n

           );


reg [25: 0] counter2;
reg led_level;
always @(posedge fpga_clk_50 or negedge hps_fpga_reset_n) begin
    if (~hps_fpga_reset_n) begin
        counter2 <= 0;
        led_level <= 0;
    end

    else if (counter2 == 24999999) begin
        counter2 <= 0;
        led_level <= ~led_level;
    end
    else
        counter2 <= counter2 + 1'b1;
end

assign LED[0] = led_level;


endmodule
